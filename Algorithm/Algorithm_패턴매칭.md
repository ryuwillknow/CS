비교한다.  긴 문자열에 내가 원하는 긴 단어를 찾는 느낌

1. 브루트 포스

한 칸씩 비교한다.

개념이 재밌다.

```python
p = 'is'
t = 'this is a book'
m = len(p)
n = len(t)

def brutefore(p, t):
	i = 0 # t index
	j = 0 # p index
	while i < n and j < m: # 성공 개념이 끝까지갔다. 실패 개념 끝까지 갔다!!
		if t[i] != p[j]: # 계속 더하기 위해서 ㅋㅋㅋ 이거 좋다.!!
			i = i - j #뒤에서 1을 더하니까
			j = -1
		i += 1
		j += 1
	if j == m : return i - m #검색 성공  성공 개념이 끝까지 갔다!!!
	else: return -1  #검색 실패

# 패턴이 여러개 있을 때
```

하지만 시간 복잡다고 O(mn)이 된다.

비교횟수를 줄일 방법은 없을까?

1. 카프 라빈 알고리즘

1. KMP 알고리즘 (이런거는 엄청 긴 텍스트에서 엄청 긴 텍스트를 찾을 때 효율이 느껴진다.)

O(m + n)

찾고자 하는 텍스트안에 패턴을 파악하자. 처음 몇글자와 일치하는 몇글자가 텍스트 안에 있으면 불일치 했을 때 텍스트의 패턴에서 시작한다.

1. 보이어 - 무어 알고리즘

상용소프트웨어에서 채택한 알고리즘

오른쪽 끝 문자를 찾아 비교한다. 없으면 패턴 길이만큼 이동한다

불일치 하지만 끝문자와 비교한 문자가 패턴내에 존재하면 당긴다

오메가

최악은 세타(mn)

일반적으로 세타(n)

- big O  = 최악의 경우, 세타 = 대부분 이정도,

## 압축하기

abbbbbbbcccc

a1b7c4 로 만든다.

더 효율적인 알고리즘은 허프만 코딩이다!!
