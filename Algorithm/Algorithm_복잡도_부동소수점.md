## 복잡도

공간적 효율성 - 메모리 줄이기

시간적 효율성  - 연산량 줄이기

복잡도가 높을수록 효율성이 저하된다.

하드웨어 환경에 따라 처리시간이 달라진다. (리모콘, 등등 다양한 하드웨어가 있다. 임베디드 영역?)

부동소수 처리프로세스, 나눗셈 가속기능 유무

시간 복잡도는 입력에 대한 크기를 나타내는 함수이다.

##

오 오메가 세타 

빅 오는 최악의 경우

빅 오메가는 예보다는 위에있어 ( 최소한 이만큼 걸린다 )

빅 세타는 오와 오메가가 같으면 표기

비트연산자

```python
a = 10
b = '0b1010'
print(f'{a:b}')
print(bin(a))

```

## 비트연산자

&  :  두 수의 비트 중 모두 1인 부분만 1인 비트를 출력한다.

|    :   두 수의 비트 중  하나라도 1인 부분만 1인 비트를 출력한다.

1 << n    :    비트를 왼쪽으로 n칸 이동한다  즉 **곱하기 2**n**이 된다.

1000 >> n  :  비트를 오른쪽으로 n칸이동한다 즉 **나누기 2**n의 몫**이 된다 ( 1000 // 2*n)

즉 if X  &  (2<<n):  은 그 자리에 비트가 있으면 2<<n이 return되어 True가 된다.

## 부분집합

```python
a = list(map(int, input().split()))
n = len(a)
rlt = []
for i in range(2**n):
    temp = []
    for j in range(n):
        if i & 2**j:
            temp.append(a[j])
    rlt.append(temp)

# 쉽게 리스트 컴프리핸션 부분집합
rlt = [[a[j] for j in range(n) if i& 2**j] for i in range(2**n)]
```

## 부동소수점

```python
& # 비트 검사 혹은 특정 비트를 0으로
| # 특정 비트를 1
^ # 비교해서
~ # 반전
```

비트연산 연습

0 : 00000000

1 : 00000001

-1 : 11111111

엔디안

컴퓨터 메모리 같이 1차원 공간에 여러개의 연속된 대상을 배열하는 법

하드웨어 아키텍쳐마다 다르다.

빅엔디안 : 큰게 먼저오는 

리틀엔디안 : 작은게 먼저오는

sys.byteorder 로 확인 가능

## 진수

0x  16진수

0b  2진수

0o  8진수

계속 왼쪽으로 보낸다. 몫이 된다. 나머지는 끝자리 

가장 높은 자리를 MSB라고 한다. 가장 작은 자리는 LSB이다.

타진수로 변환하기  (2 -8, 2-16, 8-16)

10진수로 변환하기

1의 보수 :  부호 빼고 모두 반대로

2의 보수 : 1의 보수방법으로 표현된 값에서 최하비트에 1을 더한다. ( - 붙이기?)

2의 보수는 -0이 없다  (연산속도가 비약적으로 높겠다!!!)

```python
~1  # -2
~10 # -11
~100 # -101
```

## 실수

2진수의 소수를 무한정으로 쓸 수 없기떄문에 

실수를 표현하기 위해 부동소수점을 사용한다.

1.xxxxx * 2**3 : 부동소수점  무조건 1.xxx로

단정도 실수 32비트

000000000, 10진수로 0 인 것이  - 127이다!! 

배정도 실수 64비트

소수점 몇째자리까지 저장이 되는가? 

실수형은 유효자리수를 쓴다.  전체 자리수가 몇개까지 !!!

앞에가 커지면 뒤가 작아진다!!! 배정도를 많이 쓴다. 

실수를 근사적으로 표현한다! 그래서 이 한계를 알고 오차를 줄여야한다.

유효자리수  32비트는 대략 6자리

64비트는 대략 15자리(권장사항이다)

파이썬은 내부적으로 더 넓은 범위의 실수를 표현할 수 있다.
