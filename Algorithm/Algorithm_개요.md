# 알고리즘 개요

문제를 해결하기 위한 절차나 방법

## 의사코드 = 슈도코드

연습하자

## 좋은 알고리즘

정확성

작업량

메모리 사용량

단순성

최적성

좋은 알고리즘은 작업량을 줄인다. 

## 시간 복잡도

실제 걸리는 시간 - 연산의 횟수

## 빅오 표기법 O(n)

---

가장 큰 영향력을 주는 n에 대한 항만 표시한다.

숫자면 고정된 횟수를 갖는다. O(3) 같은 것

효율적인 알고리즘을 짜는 법. 더 작은 시간복잡도의 알고리즘을 할용할 수 있는가

10억번 연산은 = 1초 대략적으로

## 배열 : 하나의 이름으로 열거하는 자료구조

---

쉽게 편수 선언할 수 잇다 + 변수로 하기 힘든 작업을 배열로 활용 가능

- 1차원 배열

Arr = list() , Arr = [] 등등

Gravity 예제

[7,4,2,0,0,6,0,7,0] 오른쪽으로 90도 회전

오른쪽에 작은애가 몇개인가  그중 가장 큰 값을 찾으면 된다. ( 최대값 찾기를 직접, max값 생성후 비교 후 넣기)

알고리즘은 파이참 사용한다.

내장함수는 사용금지

크기 미리 정해놓고 풀기 append하지말기

- 정렬

내림차순, 오름차순

버블 정렬 (반드시 원리 이해)

카운팅 정렬 (반드시 원리 이해)

선택 정렬 (반드시 원리 이해)

퀵 정렬

삽입 정렬

병합정렬

### 버블정렬

---

인접한 원소끼리 자리를 교환하면서 맨마지막 자리까지 이동한다.

한단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

교환하며 자리를 이동하는 물위에 올라가는 거품의 모양과 같다고 하여 버블정렬이라고 한다.

시간 복잡도는 O(n**2) - 효율적이지 않는데 어떻게든 돌아가겠군

두개씩 비교한다. 

첫번째 단계에서는 가장 큰 애가 맨 뒤로 간다.

두번째 단계에서는 두번째 큰애가 n-1로 간다. ….

가장 큰애를 밀어내는 정렬

이 작업을 

for i : n-1 → 1  (i는 구간의 끝)

for j : 0 → i -1

if A[j] > A[j+1]

A[j]↔ A[j+1]

## 파이참과 디버깅

---

파이참 - run으로 실행

주석 많이 달기

디버깅

파이참은 IDE

가상환경 다룰 수 있고 디버깅이 좋다. 

커뮤니티 붙은 소프트웨어는 무료버전이다. 장고 서포트는 지원하지 않는다. css java script도 지원하지 않는다. 그래서 vsc를 쓴다. 

VSC는 메모장 느낌

문제를
