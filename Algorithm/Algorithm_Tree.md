# Tree

비선형 구조 - 무슨 의미?

원소들 간에 1:n 관계를 가지는 자료구조

계층형 구조다.

최상위 노드를 root라 한다.

각각 root가 아닌 다른 노드가 root가 되는 트리를 subtree라 한다.

위에 있는 노드가 부모, 아래 노드가 자식

형제 노드 = 부모가 같은 노드들

조상 노드 = 루트까지 이르는 경로에 있는 모든 노드

자손 노드 = 서브트리에 있는 하위레벨 모든 노드

리프 노드 = 단말노드  자식이 없다

차수 = 노드에 연결된 자식 노드의 수

레벨 = 0 은 root  레벨 1도 가능하다. 

## 이진트리

자식노드를 2개까지만 가질 수 있는ㄴ 트리

left child node, right child node

i레벨의 노드의 최대 개수는 2 ** i

높이가 h인 이진트리의 노드 최소개수는 h+1 최대 개수는 2**(h+1) - 1이다.

- 포화 이진트리  Full Binary Tree
- 완전 이진트리 Complete Binary Tree  : 중간번호가 빠지지 않는 트리  - 왼쪽으로 가야한다.
- 편향 이진트리 Skewed Binary Tree : 한쪽으로만

순회는 트리노드를 중복되지 않게 전부 방문하는 것

이진트리의 순회

전위 순회 VLR

중위 순회 LVR

후위 순회 LRV

## 이진트리 저장법

부모노드  =  i/2  버림

왼쪽 자식 노드  =  2 * i

오른쪽 자식 노드 = 2 * i + 1

레벨 n의 시작노드 = 2**n

선입견 없다. 부모가 빠르지 않을 수도 있다.

지 멋대로다.

0번 쓸 수도 있다…

1. 포화면 리스트

2. 포화가 아니면

부모번호를 인덱스로 자식번호를 저장 ( 2개 필요 )

자식번호 인덱스로 부모번호 저장 - 부모가 없는 노드가 root

전위 순회 plr

후위 순회 lrp

중위 순회 lpr

트리는 잘못이 없다.

이진 탐색 트리  왼쪽은 작다. 오른쪽은 크다. 

중위 순회로 자료를 배열한다!!!!!!

이진탐색트리는 탐색이 쉽다.

노드가 키보다 작으면오른족

노드카 키보다 크면 왼쪽

삽입연산 없으면 붙여라!

삭제연산 - 자식없을 때는 그대로, 자식있으면 부모를 연결, 루트라면 왼쪽 서브의 가장 끝값을 올린다.

# DFS BFS 트리

순서는 지키지 않는다. 트리 먼저

## 트리

가장 마지막 노드들이 단말 노드, 잎노드 leaf라 불린다.

부모와 자식

서브트리, 형제노드(같은 부모), 조상노드, 서프트리, 자손노드

트리 저장법

```python
[[0,0,0]..]
[]
[[3,4],[1,3,4]]
# 내가 간선과 노드들을 잘 표현하면 되는 거지 정석은 없다.
```

## 이진트리

노드의 최대 개수가 2**i개 이다

높이 h인 이진트리는 2*(h+1) - 1개의 노드가 있다. 리스트로 [0] * 2 ** (h + 1)로 표현된다.

포화이진트리

완전이진트리

편향이진트리

- 이진트리 순회(traversal)

전위순회  VLR

중위순회  LVR

후위순회  LRV    자신을 기준한다.

```python
def binary_search(nod):
	if nod != 0:
		print('v')
		search(L)
		search(R)

# 이거 하려면 [[0, 0, 0], ...] 형식으로 저장?
# 아니면 완전이진트리만 가능? 아니어도 됨.
# nodes[0]만 있으면 된다...? 짬통?
# 0인 트리로 쭉? 이것도 괜찮네 [0 for i in range(2**n)]
# 이건 dfs이다...???? 약간 다르다,,  개념적으로 다른 것!!!! 탐색하는 방법과, 순회하는 법
# 개수가 정해져있을 때는 순서 조절이 가능하다(서열 때문에 visited가 없다)
```

- 일반 탐색 2진이 아닐 때

```python
[[ ] for _ in range(n + 1)]
# 양쪽 append
# visited(한방향만 + 기록용)
# q를 활용 , bfs?
# for문에서 잘못간 곳 찾아준다. [] 이거나 visited != 0이니까

# 2차원 배열은 너무 빡세다. 
```

- 이진트리 표현

```python
#부모노드
node // 2
#L
node % 2
#R
node & 2 + 1
#레벨의 시작점
2 ** level
```
