# Python 알고리즘 고급

stack을 활용한 여러 알고리즘

재귀호출, DP, DFS, memoization   등등? 재귀호출은 스택인가? 아닐 듯

재귀 자체는 너무 연산이 많으 드니까 재귀 계산한 값을 리스트에 저장한다.  memoization도 비슷하다.

동적계획법은 제대로된 정의와 개념을 파악해야한다.

DFS : 이제 진짜 시작이다. 아자아자  

스택을 활용한다. visited값이 0이라면 stack에 저장한다. 이거까지는 알겠는데  (내 생각에는 visited는 이 문제에만 해당한다. - 절대아니죠ㅋㅋㅋㅋ)

DFS는 채우는 느낌이다. 가본길이니까 가지마세요

이차원 배열을 통해 연결유무를 파악한다.

그렇다면 분기점에서 갔던 곳이 아니고 다음이라는 것. 이걸 어떻게 아냐고 그러면서 연결되어있을 수도 있어.

갈림길 당 배열 2개? - 재귀가 필요한가?

> max  = min
max([4,3])
#3
> 

특별 팁

while써서 다음 것이 숫자인가를 보는 것보다

일단 받고 이전 것이 숫자인가 확인하는 것이 더 쉽다.

## DFS

활용법 : 경로까지 갈 수 있는가에 대한 알고리즘이다!!!

착각 : 모든 경로를 가본다

```python
# 8방향 꿀팁
for dx in range(-1, 2):
	for dy in range(-1, 2):
		if dx == 0 and dy == 0:
			continue
```

and는 *이다.  or은  +이다.

뒤를 돌아보자

백만장자, 암호

16진수는 그냥 읽으면 된다.

이미 있는 변수에서 바꾸자. 그게 제일 빠르고 연산이 적다.

for문 진짜 절대의미없다.

그냥 direction이 훨씬 빠르다.

상하좌우 조심하자

일단 정석으로 하고 그 다음에 백트래킹하자 모든 경우는 일단 포함해야하니까

찾는 것보다 움직이는게 빠르다

dfs 와 bfs visited의 위치

2차원 배열 visited  - dfs 재귀? 갔던 길을 또 가야할 수도 있을 때

# 새로운 시작

### 병합정렬

1이거나 0이면 그냥 뺀다

나눠서 정렬한다

합친다. ( 합치는 과정 - 왼쪽 오른쪽 비교하면서 pop하면서 넣기 없으면 extend)
