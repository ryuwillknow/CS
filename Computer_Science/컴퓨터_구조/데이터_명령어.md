## 데이터

보수를 통해 음수를 만든다. 플래그를 통해 이 수가 음수인지 양수인지 판단.

문자 인코딩이 기계어, 어셈블리어로 바꾸는 과정, 문자 디코딩이 사람이 이해할 수 있는 문자로 바꾸는 과정

아스키코드 → EUC-KR (완성형 인코딩, 글자에 부여된 값을 인코딩값으로 삼음) → 유니코드(UTF-8, UTF-16 등, )

## 명령어

고급언어와 저급언어로 나뉜다.  저급언어에는 기계어와 어셈블리어가 있다.

컴파일 언어는 소스 코드 전체를 저급언어로 변환하여 실항하는 고급언어. 컴파일러 필요하다. 인터프리터 언어는 소스코드가 한 줄 씩 실행되는 고급언어

저급언어라고 모두 바로 실행할 수 있는 것은 아니다.  링킹이라는 작업을 거쳐야 실행파일이된다.

명령어의 구조 : 연산코드와 오퍼랜드로 구성되어있다. 연산코드는 연산의 내용 오퍼랜드는 연산에 사용할 데이터가 저장된 위치이다. 오퍼랜드의 개수에 따라 명령어를 구분할 수 있다. (0-주소 명령어, 1-주소 명령어, 2-주소 명령어)

연산코드의 유형 : 데이터 전송, 산술/논리, 제어 흐름 변경, 입출력 제어로 나눈다. 

데이터 전송 : MOVE(옮기기), STORE(저장하기), LOAD(메모리에서 CPU로 가져오기), PUSH(스텍에 데이터 저장하기), POP(스텍의 최상단 데이터 가져오기)

산술/논리 연산 : ADD/ SUBSTRACT / MULTIPLY / DIVIDE / COMPARE

제어흐름 변경 : JUMP  특정주소로 실행 순서를 옮겨라 CONDITIONA JUMP, HALT, CALL(되돌아 올 주소를 저장한 채 특정주소로 실행순서를 옮겨라), RETURN(CALL을 호출할 때 저장했던 주소로 돌아가라)

입출력제어 : READ WRITE START IO TEST IO

주소지정방식  오퍼랜드는 미리 정해진 주소 명령어의 데이터 크기에서 연산코드를 값을 오퍼랜드 갯수로 나눠서 갖는다. 여기에 직접 데이터를 넣지 않고 메모리 주소를 넣는다. 이 주소를 유효주소라고 한다. 레지스터가 될 수도 있고 메모리가 될 수도 있다.

데이터 그자체를 오퍼랜드에 넣는다 → 즉시 주소 지정방식

메모리의 주소를 오퍼랜드에 넣는다 → 직접주소 방식 → 단 표현할 수 있는 주소의 범위는 그대로이다.

유효주소의 주소를 오퍼랜드에 넣는다. → 간접 주소 방식 → 주소 표현 범위가 넓어진다. 대신 좀 느리다.

래지스터도 직접과 간접이 있다.
