## CPU의 작동원리

참고사항 : 위의 명령어는 CPU의 제어장치와는 다른 개념 + 제어신호는 CPU뿐만 아니라 다른 장치도 발생시킬 수 있다.

ALU :  제어장치에서 제어신호를 받고 레지스터에서 피연산자를 받은 다름에 플래그와 결괏값을 각각 플래그 레지스터와 레지스터에 보낸다. 플래그는 부호, 제로, 캐리(반올림 여부), 오버플로우, 인터럽트, 슈퍼바이저(커널보드, 사용자모드) 등이 있다. 얘네는 연산결과에 대한거다.

제어장치 : 플레그 레지스터에서 받고 명령어 레지스터에서 받고 클럭에서 신호를 받는다. 플래그 값을 참고해서 제어신호를 발생시킨다.  CPU 내부로는 레지스터와 ALU에게 외부로는 메모리와 입출력장치에 제어신호를 보낸다.

레지스터 : 프로그램 속 데이터는 반드시 레지스터에 저장된다. 프로그램레지스터(PC), 명령어레지스터(IR), 메모리주소 레지스터(MAR), 메모리버퍼 레지스터(MBR), 플래그 레지스터, 범용 레지스터, 스택포인터, 베이스 레지스터 등이 있다. 프로그램 카운터는 메모리에서 가져올 명령어의 주소를 저장한다. 명령어 레지스터는 해석할 명령어, 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 메모리 주소 레지스터는 메모리의 주소를 저장한다. CPU가 읽어 들이고자 하는 주소값을 저장한다. 메모리 버퍼 레지스터는 메모리와 주고 받은 값을 저장하는 레지스터이다. 

가벼운 사이클 : 메모리의 1000부터 1500까지 하나의 프로그램이 저장되어 있는 상황, 프로그램 카운터에 1000 저장되고 메모리 주소 레지스터에 1000 저장된다. 메모리 1000에 제어신호를 보내고 해당 메모리에 저장된 값이 메모리 버퍼에 데이터 버스를 통해 전달된다. 그값은 다시 명령어 레지스터로 이동하고 제어장치는 명령어 레지스터를 해석해서 제어신호를 보낸다. 프로그램 카운터는 1증가한다.

이외의 레지스터 : 범용 레지스터(주소도 가능, 데이터도 가능), 플래그 레지스터(ALU 연산결과를 플래그에 저장)

특정 레지스터를 이용한 주소 지정방식 : 스택포인터를 활용해 스택 주소지정방식을 사용할 수 있다. 스택 영역은 메모리에 있다. 스택 포인터는 가장 윗부분을 가리킨다. 상대주소 지정방식은 프로그램 카운터에 오퍼랜드의 숫자를 더한 주소를 얻는 방식이다. if문과 유사하다. 베이스 레지스터 주소 지정방식은 베이스 레지스터에 저장된 기준 주소로부터 얼마나 떨어진 주소를 얻어내는 방법이다. 

명령어 사이클과 인터럽트 : CPU는 명령어를 하나씩 수행한다. 인출 사이클과 실행 사이클로 나눌 수 있다. 하지만 간접 주소 지정 방식에서는 메모리 접근이 더 필요하므로 간접 사이클을 거쳐서 실행사이클로 넘어간다.

인터럽트 : 동기와 비동기로 나뉜다. 동기는 예외처리라고 보자. 비동기는 하드웨어 인터럽트라고 하자.  인터럽트 플래그로 막을 수 있는 요청이 있고 아닌 요청이 있다. 

하드웨어 인터럽트 처리순서 : 입출력 장치는 cpu에 인터럽트 요청 신호를 보낸다. cpu는 실행싸이클이 끝나고 명령어 인출 전 인터럽트 여부확인. 있다면 인터럽트 플래그를 통해 현재 실행가능한지 판단. 실행가능시 현재작업 백업(메모리의 스택 영역에 모두 저장). 인터럽트 서비스 루틴 실행.

예외 종류 : 폴트(예외 발생한 명령어 부터 실행), 트랩(예외 발생한 다음 명령어부터, 디버깅 사용?), 중단(강제 종료) 소프트웨어 인터럽트(시스템 호출에서)
