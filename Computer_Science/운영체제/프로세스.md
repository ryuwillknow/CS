## 프로세스

실행 중인 프로그램: foreground process, background process. service는 백그라운드 프로세스 중 사용자와 소통하지 않는 프로세스. CPU자원은 한정적이기 때문에 타이머 인터럽트가 발생하면 차례를 양보하고 다름 프로세스를 실행한다. 이를 위해 PCB(프로세스 제어 블록)을 이용한다.  PCB는 프로세스 관련 정보를 저장하는 자료구조이다. 커널영역에 생성되고 실행이 끝나면 폐기된다. PCB 안에는 프로세스 ID, 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관리 정보, 사용한 파일, 입출력장치. 문맥교환은 기존의 프로세스 문맥을 PCB에 백업하고 새로운 프로세스를 PCB로부터 복구하는 것.

프로세스의 커널 영역에는 PCB가 생성된다. 사용자 영역에는 코드영역, 데이터 영역, 힙영역, 스택영역으로 나뉘어 저장된다. (프로그램별로 다 있다!!)코드 영역에는 기계어로 이루어진 명령어가 저장된다. 읽기 전용공간이라 쓰기가 불가능하다. 데이터 영역에는 잠깐 썼다가 없어질 데이터가 아닌 프로그램이 실행되는 동안 유지되는 데이터가 저장된다. 전역번수가 대표적이다. 코드 영역과 데이터 영역의 크기는 변하지 않는다. 이부분을 정적 할당영역이라고 한다. 반대로 힙과 스택은 동적할당영역이다. 힙영역은 프로그래머가 직접 할당하는 저장 공간이다. 공간을 할당했으면 반환해야한다. 메모리 누수가 발생하기 때문이다.  스태영역은 데이터를 일시적으로 저장하는 공간이다. 함수가 실행되면 사라지는 매개변수, 지역변수가 대표적이다. 

[메모리와 파이썬, 자바](https://pearlluck.tistory.com/758) - 근데 동적할당, 정적할당 정의가 다른듯?

프로세스 상태와 계층구조 : 프로세스 상태는 생성상태(new, PCB를 할당받은 상태), 준비상태(ready, 실행상태로 바뀌는 것을 dispatch라 한다.), 실행상태(running, cpu에서 실행중인 상태, 타이머인터럽트가 나면 준비상태로), 대기상태(blocked, 프로세스 도중 입출력 사용), 종료상태(terminated)가 있다. 프로세스는 실행도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다. 부모프로세스와 자식프로세스로 구분된다. 다른 PID를 갖는다. 자식은 또 자식을 낳을 수 있으므로 계층구조가 생긴다. 자식 프로세스는 자신을 복제(fork, 시스템 호출)한 후 자신의 메모리에 새로운 프로그램을 덮어씌운다(exec, 시스템 호출). [이과정 깃허브](https://github.com/kangtegong/self-learning-cs/blob/main/process/process_python.md#python%EC%9C%BC%EB%A1%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8B%A4%EB%A3%A8%EA%B8%B0) idle에서는 안된다. pycharm에선 됨 근데 병행실행이라 순서가 뒤죽박죽이다.

스레드 : 실행 단위이다. 하나의 프로세스가 여러 개의 스레드를 가질 수 있고 여러 일을 동시에 처리할 수 있다. 스레드는 각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터값, 스택으로 구성된다. 스레드 ID는 pcb에? 프로그램 카운터 값은 프로세스의 코드영역에 스택은 스택영역에 저장된다. 중요한 점은 프로세스의 스레드들이 실행에 필요한 최소한의 정보만 유지한 채 프로세스 자원(코드, 데이터, 힙)을 공유하며 실행된는 점이다. 

멀티코어면 parrallel 단일 코어면 currency하게 수행한다. 

멀티프로세스와 멀티스레드 : 멀티프로세스는 fork해서 exec 한다. 자원을 공유하지 않는다. 즉 같은 작업을 반복하는 것이 목적이면  메모리 낭비가된다. 단 멀티스레드는 하나의 스레드가 문제가 생기면 프로세스 전체에 문제가 생길 수  있다.

CPU 스케줄링 : 프로세스마다 우선순위가 다르다. 거기에다 프로세스 모두 CPU와 입출력장치를 사용하는데 어떤 입출력장치는 입출력 작업을 많이 하기도 하고 동영상, 수학 연산과 같이 CPU작업을 많이 하는 프로세스가 있다. 둘을 입출력 집중 프로세스와 CPU 집중프로세스로 구분한다. 만약에 입출력 집중 프로세스와 CPU 집중 프로세스가 동시에 CPU에 요청이 들어온다면 입출력 집중 프로세스를 먼저 실행시켜서 CPU 작동시간을 줄인다. 이처럼 상황과 중요도에 맞게 운영체제는 프로세스에 우선순위를 부여한다. 운영체제는 스케줄링 큐를 구현해 프로세스의 우선순위를 정한다. 대표적으로 준비 큐와 대기 큐가 있다. 프로세스는 cpu 계산 후 입출력을 하므로 준비 큐에서 CPU 사용할 차례를 기다리고 운영체제는 우선순위가 높은 프로세스를 먼저 실행한다. 줄을 세워도 상관없음. 대기큐는 입출력 별로 큐가 나뉘어져 있다. cpu 사용을 마치고 입출력 요청이 있으면 대기큐에 들어가고 입출력이 완료되면 인터럽트를 발생시켜 준비큐로 보낸다. 선점형 비선점형 스케줄링은 프로세스 자원을 강제로 빼앗을 수 있는가 여부로 갈린다. 비선점형 스케줄링은 프로세스가 종료되거나 대기상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 방식을 의미한다. 선점형 스케줄링은 문맥교환 과정에서 오버헤드가 발생할 수 있다. 대신 프로세스를 골고루 배분할 수 있다.

CPU 스케줄링 알고리즘 : 선입 선처리 스케줄링(FCFS)은 들어온 순서대로 프로세스를 처리하는 비선점형 스케줄링 방식. 단 짧은 실행시간이지만 긴 시간을 기다리는 호위효과를 발생시킨다. 최단 작업 우선 스케줄링(SJF)은 짧은 프로세스를 먼저 실행하는 것이다. 라운드  로빈 스케줄링은 각 프로세스 별로 CPU를 사용할 수 있는 시간을 표현한 타임슬라이스를 활용하는 선점형 스케줄링이다. 타임슬라이스의 적절한 크기가 중요하다. 최소 잔여시간 스케줄링(SRT)도 있다. 우선순위 스케줄링은 프로세스에 우선순위를 부여하고 가장 높은 우선순위부터 실행한다. 이 방법은 낮은 순위를 계속 실행하지 못하는 기아현상이 생길 수 있다. 이를 방지하기 위해 에이징 기법을 사용한다. 오래 기다린 프로세스의 순위를 점차 높이는 것이다. 다단계 큐 스케줄링은 순위 별로 큐를 만들어서 실행하는 것이다. 우선순위가 높은 큐에 CPU 집중 프로세스를 삽입할 수 있다. 큐별로 타임슬라이스를 여러개 지정할 수 있고 다른 스케줄 알고리즘을 사용할 수 있다.  다단계 피드백 큐 스케줄링은 우선순위 간의 이동이 가능해서 기아현상을 막는다. 타임슬라이스 동안 실행을 못 마친 프로세스는 낮은 우선순위로 이동한다. 너무 오래 기다리면 우선순위 큐로 이동시킨다. 이게 가장 일반적이다.
