## 가상메모리

연속메모리할당 : 스와핑 기법은 오랫동안 사용하지 않은 프로세스나 입출력 요구로 대기상태에 있는 프로세스를 보고기억장치 일부영역에서 쫓아내고 빈공간에 다른 프로세스를 적재하여 실행하는 방식을 의미한다. 스왑영역 스왑인 스왑 아웃. 프로세스는 메모리 내의 빈 공간에 최초적합, 최적적합, 최악적합 세가지 방식으로 적재할 수 있다. 최초적합은 빈공간 발견즉시 메모리에 할당하는 방식으로 검색을 최소화하고 빠른 할당이 가능하다. 최적적합은 빈공간을 모두 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 적재. 최악적합은 빈공간을 모두 검색해 본 후 공간 중 가장 큰 공간에 적재한다. 하지만 외부단편화(프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 메모리가 낭비되는 현상)는 막지못한다. 압축해도되지만 시간이 걸리고 오버헤드를 야기하고 옮기는 동안 실행이 중단되기 때문에 가상메모리 기법과 페이징 기법을 주로 사용된다.

페이징 : 가상메모리는 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다. 가상 메모리 관리 기법은 페이징, 세그멘테이션이 잇는데 페이징을 많이 쓴다. 페이징이란 메모리와 프로세스를 일정한 단위로 자르고 메모리를 불연속적으로 할당하여 외부단편화를 막는 방법이다. 프로세스의 논리주소를 페이지라는 단위로 자르고 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 단위로 자른다음에 할당한다. 전체를 스와핑하지 않고 페이지 단위로 스와핑하고 이과정을 페이지 인 페이지 아웃이라고 부른다. 이렇게 하면 일부분만 메모리에 적재할 수 있다. (용량이 큰 게임??) 페이지 테이블은 불연속적인 물리주소를 연속적인 논리주소로 배치할 수 있게끔 만들어준다. 프로세스마다 각자의 테이블이 있고 페이지번호와 프레임 번호를 1:N으로? 한다 ㅋㅋ 페이지 테이블은 메모리에 적재되어 있다. CPU 내부의 페이지 테이블 베이스 레지스터에 적제된 주소를 가리킨다.  하지만 이렇게 테이블을 사용하면 두 번 접근해야하므로 시간이 두배 늘어난다.(테이블 한번 프레임 한번) 이와 같은 문제를 해결하기 위해 TLB(Translation Lookside Buffer)라는 페이지 테이블의 캐시 메모리를 만든다. 최근 사용된 페이지 위주로 가져와서 저장하겠지. 페이지 번호가 TLB에 있을 경우 TLB 히트라하고 없으면 TLB 미스라고 한다. 없으면 테이블에 접근해야한다. 페이징에서 주소를 바꾸는 법은 접근하고 싶은 <페이지, 변위>를 페이지 테이블을 보고 <프레임, 변위>로 바꾼 후 접근한다. 페이지의 각각행들을 페이지 테이블 엔트리라고 하는데 유효비트 , 보호비트, 수정비트 등 중요한 정보가 담겨있다. 유효비트는 현재 해당 페이지에 접근이 가능한지 여부를 알려준다. 스왑영역에 잇는경우 0이고 페이지가 메모리에 적재되어 있으면 유효비트는 1이된다. 0이면 페이지 폴트라는 예외를 발생시킨다.(페이지를 메모리에 가져옴) 보호비트는 페이지가 읽기만 가능한지 쓰기가 가능한지 등을 보여준다. r, w, x 로 구성할 수 있고 110이면 읽고 쓰는 것은 가능하지만 실행은 불가능하다. 참조 비트는 cpu가 이곳에 접근한적있는지 여부를 나타낸다. visited와 같다. 수정비트는 해당 비트에 데이터를 쓴 적 잇는지 없는지를 알려준다. 스왑 아웃할 때 추가작업 없이 새로 적재된 페이지로 덮어쓴다.(개념 잘 이해안됨) 수정되었으면 변경된 값을 보조장치에 추가로 기록해야한다.  페이징의 장점은 프로세스간의 페이지를 공유할 수 잇다는 점이다. 쓰기시 복사에 유리하다. 다른 부분만 만들고 같은 부분은 함께 사용가능하다는 것! 공유한 페이지에 쓰기 명령이 생기면 바로 복사본을 만든다!!! 생성시간단축과 공간절약! 페이지 크기가 작으면 페이지 테이블의 크기가 커지기 때문에 메모리가 낭비될 수 있다. 이를 막기위해 계층적 페이징 기법을 사용한다. 계층적 페이징 기법은 페이지를 여러개로 쪼개고 이 페이지를 가리키는 테이블을 또 만드는 기법이다.  필요없는 것은 보조 기억장치에 둔다.  필요할 때만 적재한다. 대신 논리 주소가 달라진다. <페이지, 변위> 였지만 <안쪽 페이지, 바깥 페이지, 변위> 이런 식으로 논리주소가 구성된다.대신 계층이 많으면 페이지폴트가 발생했을 때 더 많이 참조해야한다.

요구 페이징 : 프로세스를 메모리에 적재할 때 필요한 페이지만 적재하는 기법을 요구 페이징이라고 한다. 아무런 페이지도 메모리에 적재하지 않고 실행할 수도 있다. 이러면 페이지 폴트가 계속발생하다가 빈도가 떨어진다. 이를 순수 요구 페이징이라고 한다. 페이징 시스템을 안정적으로 작동하려면 페이지 교체와 프레임 할당을 잘 수행해야한다. 메모리가 가득차면 페이지 교체 알고리즘을 통해 적재된 페이지를 보조기억장치에 보낸다. 페이지 폴트를 가장 적게 일으키는 알고리즘이 좋은 알고리즘이다. 스왑 아웃을 잘 골라서 해야한다. 다시 불러오면 컴퓨터 성능을 저해한다. 페이지 폴트 횟수를 페이지 참조열을 통해 알 수 있다. FIFO 페이지 교체 알고리즘은 가장 먼저 올라온 페이지부터 내쫓는 방식이다.(오래된거 먼저 나가라) 이를 보안한게 2차 기회 페이지 교체 알고리즘이다. 가장 오래된 페이지가 참조비트가 1이면 지금 순간을 적재된 시간이라 바꾸고 참조비트를 0으로 만든다. 기회를 한 번 주는 것. 최적 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다. 참조 빈도가 가장 낮을 것이라 예상되는 페이지를 먼저 내보낸다. 페이지 폴트율이 가장 낮다. 하지만 실제 구현이 어렵다. 오랫동안 사용되지 않을 페이지를 예측하기 어렵다. 다른 페이지 교체 알고리즘의 이론상 성능을 평가하는 목적으로 사용된다. LRU 페이지 교체 알고리즘은 오랫동안 사용하지 않은 것을 먼저 내보내는 것이다. 최적 페이지 교체 알고리즘은 예상이지만 LRU은 일어난 일이다. 페이지마다 마지막에 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체합니다. 페이지 폴트가 발생하는 다른 이유는 프레임 수가 적은 것도 있다. 페이지 교체에 너무 많은 시간을 쏟기 때문이다. 이런 현상을 스래싱이라고 한다. 멀티 프로그래밍이 증가하면 cpu 이용률이 증가하다가 어느순간 급격히 저하된다. 이유는 페이지 교체 때문. 스레싱의 근본원인은 각 프로세스 별로 필요한 ‘최소한의 프레임수’가 보장되지 않았기 때문. 모든 프로세서에 균등 할당할 수도 있고 비례 할당할(프로세스의 크기에 따라) 수도 있다. 하지만 실행시 프레임이랑 프로세스의 크기가 비례하는 것은 아니기 때문에 작업 집합 모델, 페이지 폴트 빈도 이 두 방식으로 프레임을 배분한다. 작업 집합 모델은 프로세스가 ‘일정 기간 동안 참조한 페이지 집합’을 기억해 페이지 교체를 방지한다. ex 3초동안 20개 프레임 집중적으로 참조했으면 최소한 20개의 프레임을 할당한다. 이런 참조한 페이지의 집합을 작업 집합이라고 한다. 이거 중요!!! 그 시간 이전 몇초동안 몇게의 프레임이 생성되었는가? 페이지 폴트 빈도 방식은 폴트율이 너무 적으면 많은 프레임을 갖고 있고 폴트율이 너무 높으면 적은 프레임을 가지고 있다는 아이디어에서 시작했다. 폴트율의 상한선과 하한선을 긋고 하한선보다 낮으면 프레임 수를 줄이고 상한선보다 높으면 프레임 수를 늘린다.
